# API Reference

This is a reference for the internal APIs of `because.js`. If you just want to
get a quick start on using `because.js`, check out the README at the root of
the repo; this document isn't necessarily the right place for that. If you want
more in-depth technical detail, then this document is what you want.

If you are looking for references on specific components of `because.js`,
search or start clicking links (in a maximized browser window, you can find the
names of modules to the right). Other than this page, the rest of this
reference is all automatically extracted from code comments and rendered by
typedoc.

Otherwise, if you want a narrative overview of the internals, this page is your
best resource.


## Ways to consume because.js

Whether you're just trying to use `because.js` seriously or participating in
its development, you should be acquainted with the several ways that it can be
consumed.

To summarize, `because.js` can be used in the following general ways:
* several ways of loading a bundle of Javascript code in browsers,
* use from Node as either ES2015 or CommonJS,
* and use of the underlying code in your own build pipeline, for custom builds.

With the exception of the original TypeScript source code in `src/`, all of
these other formats are built by tools like `webpack` and `tsc` and all that
work is coordinated using `make`.

### Bundles

The bundles are files containing concatenated Javascript code. To support the
largest feasible range of browsers, they are all compiled as the "ES5" dialect
of Javascript. They are all created by the build process coordinated by make
and put into `dist/`. Bundles have filenames like `dist/foobar.js`. Minified
bundles are alternate versions of the same files, except they have been run
through [Uglifyjs](https://github.com/mishoo/UglifyJS2) and have names like
`dist/foobar.min.js`. Their only point is to be smaller. All the bundles are
accompanied by source maps (files ending in `.map`) which should normally be
put the same place you put the `.js` file, to help with debugging without
forcing the browsers of normal users to load all that extra data.

If you just want to make something that runs in the browser and you don't know
which bundle you want, you probably want `dist/because.js`. The technical name
for its format is [UMD](https://github.com/umdjs/umd). That means there are
multiple ways to use it, but particularly you can just use it directly in a
script tag without a separate loader. At this writing, the UMD bundle is
generated by Webpack, because `tsc` does not support generation of UMD bundles.

If you are using RequireJS as a loader, that uses [AMD
modules](http://requirejs.org/docs/whyamd.html) like `dist/because.amd.js`. If
you are using [SystemJS](https://github.com/systemjs/systemjs) as a loader, you
may want `dist/because.system.js`. At this writing, these bundles are generated
directly by the TypeScript compiler, `tsc`.

### Modules

Alternatively, if you bring your own tools for build and bundling, you can use
`because` as a package of ES2015 modules for ES2015 (in `es2015/`) or a package
of CommonJS modules for ES5 (in `lib/`) or if you use TypeScript, you may even
directly use the original source modules (in `src/`).

In these cases, it is up to you to pick whichever parts you need and figure out
how to compile them for whatever target environment you have in mind.  This is
more complicated and you may be on your own when doing things this way, but it
gives the most control.


## Entry points

`because.js` is usable either in the browser or in Node. There is no weird
backend selection code, you just choose which implementation you want to use by
choosing an entry point.

The normal entry point for browsers is in `src/browser.ts`. This assumes the
presence of all the things that browsers normally have, and uses XMLHTTPRequest
as the HTTP library. The normal entry point for Node is in `src/index.ts`.

Essentially these implement the same interface by using different subclasses of
`Client` and `Transfer` wrapped up in `Frontend` (and its child
`ServiceFrontend`s). The overall idea here is to try to maximize the amount of
code shared between implementations to reduce duplication of development and
testing effort. Of course, there are practical limits to this.

In any case, the top-level object is named `Because`. You instantiate this with
`new` to get an object. When you instantiate it, you can supply an environment
name like "dev" or "test" or "prod" which determines which BCS servers are
used. You can also turn on "debug mode" which does a little more console
logging.

Before you can use any service that requires authentication (e.g. with
[JWTs](https://jwt.io/introduction/) obtained from the BCS token service and
presented to other BCS services as an `Authorization: Bearer
asdfjaskdjfksadjfkas` request header) then you have to run `because.login()`
and wait for it to complete first.

All the calls, including `because.login()`, are asynchronous. They return
promises (Promises/A+ objects). You can either chain handlers on them using
methods like `.then` or if your environment supports async, you can `await`
them.

The `Because` object has some top-level properties like `routing` which
represent particular services, and contain their own methods for getting one or
another kind of data. See the references for individual ServiceFrontends for
more details.
